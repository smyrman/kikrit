#!/usr/bin/env python
# -*- coding: utf-8 -*-

# Copyright (C) 2010: Sindre RÃ¸kenes Myren
#
# This file is part of KiKrit which is distributed under GPLv3. See the file
# COPYING.txt for more details.

from optparse import make_option

from django import db
from django.core import management
from django.core.management.base import BaseCommand
from django import VERSION as DJANGO_VERSION

from south import migration
from south.models import MigrationHistory
from south.exceptions import NoMigrations

# TODO: I have writen a patch to South that implements the same functionallety
# as this wrapper command. If that patch is applied, this entire file can be
# completly removed.

class Command(BaseCommand):
	option_list = BaseCommand.option_list + (
		make_option('--db-dry-run', action='store_true', dest='db_dry_run',
			default=False,
			help="Doesn't execute the SQL generated by the db methods, and "\
			"doesn't store a record that the migration(s) occurred. Useful "\
			"to test migrations before applying them."),
		make_option('--first-migration', action='store', type="string",
			dest='first_migration', default='0001',
			help="An alternative name to match when looking for the first "\
			"migration."),
		make_option('--no-initial-data', action='store_true',
			dest='load_initial_data', default=True,
			help='Skips loading initial data if specified.'),
		make_option('--noinput', action='store_false', dest='interactive',
			default=True,
			help='Tells Django to NOT prompt the user for input of any kind.'),
		make_option('--database', action='store', dest='database',
			help="Nominates a database to synchronize. Defaults to the "\
			"default database."),
		)

	help = "A smal wrapper for the south migrate command that makes it "\
	       "possible to automatically fake the first migration for all apps"

	args = "[app]"

	def handle(self, app=None, **options):
		# DUPLICATE OF 'south.mannagement.commands.migrate':
		# Migrate each app
		if app:
			try:
				apps = [migration.Migrations(app)]
			except NoMigrations:
				print "The app '%s' does not appear to use migrations." % app
				print "./manage.py migrate " + self.args
				return
		else:
			apps = list(migration.all_migrations())
		# END DUPE CODE

		# Django 1.1 compatibility code:
		if DJANGO_VERSION[:3] >= (1, 2, 0):
			database = options.get('database', db.DEFAULT_DB_ALIAS)
			connection = db.connections[database]
		else:
			connection = db.connection

		# Get a list of installed tables:
		tables = connection.introspection.table_names()

		# Find apps where the first migration should be faked:
		autofake_apps = []
		for app in apps:
			app_label = app.app_label()
			# GUARD: If there is migration history for this app, the first
			# migration should never be faked:
			if MigrationHistory.objects.filter(app_name=app_label,
					applied__isnull=False).count() > 0:
				continue

			# If one of the app's models have a table in the  database, assume
			# that the first migration should be skipped for app:
			for model in db.models.get_models(db.models.get_app(app_label)):
				if model._meta.db_table in tables:
					autofake_apps.append(app_label)
					break

		# Prefore a fake first migration for all apps needing that:
		south_options = {
				'fake': True,
				'verbosity': options.get('verbosity'),
				'db_dry_run': options.get('db_dry_run'),
				'no_initial_data': not options.get('load_initial_data'),
				}
		target = options.get('first_migration')
		for app_label in autofake_apps:
			management.call_command('migrate', app_label, target, **south_options)
